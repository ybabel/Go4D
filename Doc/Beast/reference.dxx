/** @name	Reference Manual
    DOC++ follows the approach of maintaining one source code that contains
    both, the C++ or Java program itself along with the documentation in order to
    avoid incompatibilities between the programm and its documentation. Unlike
    other approaches such as WEB, sources documented with DOC++ are ready to be
    compiled without need of any preprocessing (like tangle).  We feel, that this
    is of great advantage for intensive programming and debugging activities.

    This documentation is organized as follows. Section \Ref{Usage} describes
    how to generate your documentation for readily docified sources, hence
    explains the comand line options of DOC++.  Section \Ref{Manual Entries}
    discusses, how the manual entries generated for DOC++ comments are built
    up and section \Ref{Structure} how to structure your documentation
    hierarchically.  Finally section \Ref{Text Formatting} describes all the
    features provided by DOC++ to format the documentation text (such as bold
    face typesetting etc.).
 */
//@{
    /** @name Usage
    	Calling DOC++ with option #-h# will give you a long screen with one-line
	descriptions of the command line options provided by DOC++. However,
	we now attempt to provide a more detailed description suitable for a
	novice user to understand how to call DOC++ with his docified sources.

	At the commandline DOC++ may be called with a sequence of options and a
	list of files or directories.  No option may be passed after the first
	filename.  All files passed to DOC++ are parsed in the order they are
	specified for generating documentation from them.  All directories are
	traversed recursively and all files #*.h*# or #*.java# (depending on the
	-J comand line option) are parsed.  However, it is good practice to
	control the input files with one main input file and use the #@Include:#
	directive.

	Options consist of a leading character #-#, preceeded by one or two
	characters and optionally a space-separated argument.

	Command line options come in three different flavours. The first type of
	options control parameters that are independent of the chosen output,
	HTML (the default) or LaTeX (selected with option #-t#). These are:
	\begin{description}
	\item[-h]	This instructs DOC++ to print a one-line description
			of all options to the screen.
	\item[-J]	Sets DOC++ into Java mode, i.e.~lets DOC++ parse Java
			instead of C/C++.
	\item[-A]	Instructs DOC++ to generate manual entries for every
			declaration it finds, no matter if it is documented with
			a DOC++ comment or not.
			instead of C/C++.
	\item[-p]	instructs DOC++ also to include private class members
	       		to the documentation. If not specified no private
	       		member will show up in the documentation (even if they
	       		are docified).
	\item[-v]	Sets DOC++ into verbose mode making it operate more
			noisy. This may be helpful when debugging your
			documentation.
	\item[-u]	Draw arrows from derived class to the base class when
	       		generating class graphs.
	\item[-k]	Also generate class `graphs' for classes with neither
			base class nor child classes.
	\item[-H]	Instructs DOC++ to use HTML as formatting language.
	\end{description}

	The following command line options are only active when HTML output is
	selected, i.e.~no option #-t# is passed:
	\begin{description}
	\item[-d #<#name#>#]	This specifies the directory #<#name#>#, where
			the HTML files and gifs are to be written.  If not
			specified, the current directory will be used. If the
			specified directory does not yet exist, it will be
			created by DOC++.
	\item[-f]	instructs DOC++ to write on each HTML page the file of
			the source code, where this manual entry has been
			declared.
	\item[-g]	instructs DOC++ not to generate gifs for equations and
			#\TEX{}# text in the documentation. This may reduce
			execution time when calling DOC++, but note, that DOC++
			keeps a database of already generated gifs, such that
			gifs are not recreated if they already exist. However,
			if you do not have LaTeX, dvips, ghostscript and the
			ppmtools installed on your system, you {\em must} use
			this option, since then DOC++ will fail setting up the
			gifs.
	\item[-G]	This instructs DOC++ to reconstruct all gifs, even if
			they already exist. This may be useful, if the
			database is corrupted for some reason.
	\item[-B #<#file#>#]	will add #<#file#># as the bottom banner to
			every HTML page generated by DOC++.  This is how to get
			rid of DOC++ logos and customize the output for your
			needs.
	\item[-a]	When this option is specified, DOC++ will use HTML
			tables for listing the members of a class. This yields
			all member names to be aligned.
	\item[-b]	Same as #-a# except that a bordered table will be used.
	\item[-r]	This option should only be set when using DOC++ on DOS
			filesystems with 8-character-long filenames. DOC++ will
			respect this (stupid) convention.
	\item[-j]	Suppresses the generation of java applets for
			drawing class graphs.
	\end{description}

	Finally this set of command line options provides some control for the
	LaTeX output of DOC++.
	\begin{description}
	\item[-t]	Instructs DOC++ to produce LaTeX output rather than HTML.
	\item[-o #<#file#>#]	Sets the output file name.  If not specified,
			the output is printed to stdout.
	\item[-l]	Switches off the generation of the LaTeX environment.
			This should be used if you intend to include the
			documentation in some LaTeX document.
	\item[-eo #<#option#>#]	adds #<#option#># to LaTeX's #\documentclass#.
	\item[-ep #<#package#>#]	adds #\usepackage{package}# to the LaTeX
			environment.
	\item[-ep #<#file#>#]	uses the contents of #<#file#># as LaTeX
			environment.
	\item[-s]	Instead of generating a manual from the manual entries,
			DOC++ will generate a source code listing. This listing
			contains all {\em normal} C or C++ comments typeset in
			LaTeX quality.  Every line is preceeded with its line
			number.
	\end{description}

	For customization of the LaTeX output, please try to understand and edit
	the style file #docxx.sty#.  (Sorry, there is no documentation on how to
	do this.)  The HTML output can be customized by means of the following 6
	files:
	\begin{description}
	\item[#indexHeader.inc#]	Header for index HTML-pages
	\item[#indexFooter.inc#]	Footer for index HTML-pages
	\item[#hierHeader.inc#]		Header for class hierarchy HTML-pages
	\item[#hierFooter.inc#]		Footer for class hierarchy HTML-pages
	\item[#classHeader.inc#]	Header for all other HTML-pages
	\item[#classFooter.inc#]	Footer for all other HTML-pages
	\end{description}
	If one or more of these files are found in the current directory, the
	corresponding part of a HTML-page is substituted by the contents of the
	file.  The files #indexHeader.inc# and #hierHeader.inc# should start
	with #<HTML><TITLE> ...#.  File #classHeader.inc# should start with
	#<BODY> ...#, since for such pages DOC++ sets up the title.

	As an example, the LaTeX version of this document has been generated
	with
	\begin{verbatim}
	    doc++ -v -t -o doc.tex -ep a4wide doc.dxx
	\end{verbatim}
	while the HTML version has been created using
	\begin{verbatim}
	    doc++ doc.dxx
	\end{verbatim}
	As you can see, this documentation itself is written using DOC++ in
	order to gain the benefits of having just one documentation source and
	two different output possibilities.
     */

    /** @name Manual Entries
	Just like in JavaDoc the documentation for DOC++ is contained in special
	versions of Java, C or C++ comment.  These are comments with the format:
	\begin{verbatim}
	    /**
	      *  ...
	      * /
	\end{verbatim}
	Note, that DOC++ comments are only those with a double asterisk #/**#.  We
	shall refer to such a comment as a DOC++ comment.  Each DOC++ comment is
	used to specify the documentation for the {\em subsequent} declaration (of a
	variable, class, etc.).

	Every DOC++ comment defines a {\em manual entry}.  A manual entry
	consists of the documentation provided in the DOC++ comment and some
	information from the subsequent declaration, if available.

	Manual entries are structured into various {\em fields}.  Some of them
	are automatically filled in by DOC++ while the others may be specified
	by the documentation writer.  Here is the list of the fields of manual
	entries:
	\begin{center}
	\begin{tabular}{rrr}
	    Field name	& provider	& description	\\
	\hline
	    #@type#	& DOC++	& depends on source code	\\
	    #@name#	& both	& depends on source code	\\
	    #@args#	& DOC++	& depends on source code	\\
	    #@memo#	& user	& short documentation			\\
	    #@doc#	& user	& long documentation			\\
	    #@return#	& user	& doc of return value of a function	\\
	    #@param#	& user	& doc of parameter of a function	\\
	    #@exception#& user	& doc for exepction thrown by a function \\
	    #@see#	& user	& cross reference			\\
	    #@author#	& user	& author				\\
	    #@version#	& user	& version				\\
	\hline
	\end{tabular}
	\end{center}

	Except for explicite manual entries, the first three fields will
	generally be filled automatically by DOC++.  How they are filled depends
	on the {\em category} of a manual entry, which is determined by the
	source code following a DOC++ comment.  Generally they contain the
	entire signature of the subsequent declaration.  The following table
	lists all categories of manual entries and how the fields are filled
	\begin{center}
	\begin{tabular}{llll}
	    Category	& #@type#	& #@name#	& #@args#	\\
	\hline
	    macro	& \#define	& name		& [argument list]	\\
	    variable	& Type		& name		& -	\\
	function/method	& Return type	& name		& arguments list [exceptions]	\\
	union/enum	& union/enum	& name		& -	\\
	class/struct	& class/struct	& name		& [derived classes] \\
	interface	& interface	& name		& [extended interfaces] \\
	\hline
	\end{tabular}
	\end{center}
	In any case #@name# contains the name of the declaration to be documented.
	It will be included in the table of contents.

	The remaining fields are filled from the text in the DOC++ comment.
	Except for the #@doc# and #@memo# field, the text for a field must be
	preceeded by the field name in the beginning of a line of the DOC++
	comment.  The subsequent text up to the next occurrence of a field name
	is used for the field.  Field #@name# is an exception in that only the
	remaining text in the same line is used to fill the field.  As an
	example
	\begin{verbatim}
	    @author	Roland Wunderling and Malte Z\"ockler
	\end{verbatim}
	is used to fill the #@author# field with the text ``Roland Wunderling
	and Malte Z\"ockler''.

	Text that is not preceeded by a field name is used for the #@doc# field.
	The very first text in a DOC++ comment up to the first occurrence of
	character `.' is also copied to the #@memo# field.  This may be
	overridden by explicitly specifying a #@memo# field.  In this case also
	characters `.' are allowed.

	The fields #@type#, #@args# and #@doc# may not be filled explicitely.
     */

    /** @name Structure
	DOC++ automatically imposes a hierarchical stucture to the manual
	entries for classes, structs, unions, enums and interfaces, in that it
	organizes members of such as sub-entries.
	
	Additionally DOC++ provides means for manually creating subentries to a
	manual entry.  This is done via {\em documentation scopes}.  A
	documentation scope is defined using a pair of brackets:
	\begin{verbatim}
	    //@{
	        ...
	    //@}
	\end{verbatim}
	just like variable scopes in C/C++ or Java.  Instead of #//@{# and
	#//@}# one can also use #/*@{*##/# and #/*@}*##/#.  All the manual
	entries within a documentation scope are organized as subentries of the
	manual entry preceeding the opening bracket of the scope, but only if
	this is an explicit manual entry.  Otherwise a dummy explicite manual
	entry is created.

	In addition to this Java allows the programmer to organize classes
	hierarchically by means of #package#s.  Packages are directly
	represented in the manual entry hierarchy generated by DOC++.  When a
	DOC++ comment is found before a #package# statement,  the documentation
	is added to the package's manual entry.  This functionality as well as
	documentation scopes are extensions to the features of JavaDoc.
     */

    /** @name File Inclusion
     *  There is one more special type of comments for DOC++, namely
     *   #//@Include: <files># or #/*@Include: <files>*##/#.  When any of such
     *   comments is parsed, DOC++ will read the specified files in the order
     *   they are given.  Also wildcards using #*# are allowed.  It is good
     *   practice to use one input file only and include all documented files
     *   using such comments, especially when explicite manual entries are used
     *   for structuring the documentation.  This text is a good example for
     *   such a documentation.
     */

    /** @name Text Formatting
	DOC++ provides both, HTML and LaTeX output.  Both languages have
	formatting macros which are more or less powerful.  The idea of DOC++ is
	to be able to generate both ouput formats from a single source.  Hence,
	it is not possible to rely on the full functionality of either
	formatting macros.  Instead, DOC++ supports a subset of each set of
	macros, that has proved to suffice for most applications.  However, in
	one run of DOC++ the user must decide for the formating macros to use.
	The subset of each macro packet is listed in the following subsections.
	If one uses only one of the subsets, goodlooking output can be expected
	for both formats.
     */
    //@{
	/** @name supported LaTeX macors
	    This is the subset of LaTeX formatting instructions provided by
	    DOC++:
	    \begin{description}
	    \item[#$#...#$#]	math mode for inline equations
				(example $\sqrt{\frac{x^2}2}$).
	    \item[#\##[#...#\##]#]	display math mode
	    \item[#\#\#]	to output character \#
	    \item[#\#\_]	to output character "#_#"
	    \item[#\#\ ]	to output character "# #"
	    \item[#\#em]	only to be used as #{\em ...}#
	    \item[#\#bf]	only to be used as #{\bf ...}#
	    \item[#\#it]	only to be used as #{\it ...}#
	    \item[#\#tt]	only to be used as #{\tt ...}#
	    \item[#\#tiny]	only to be used as #{\tiny ...}#
	    \item[#\#scriptsize]	only to be used as #{\scriptsize ...}#
	    \item[#\#footnotesize]	only to be used as #{\footnotesize ...}#
	    \item[#\#small]	only to be used as #{\small ...}#
	    \item[#\#large]	only to be used as #{\large ...}#
	    \item[#\#Large]	only to be used as #{\Large ...}#
	    \item[#\#LARGE]	only to be used as #{\LARGE ...}#
	    \item[#\#huge]	only to be used as #{\huge ...}#
	    \item[#\#Huge]	only to be used as #{\Huge ...}#
	    \item[#\#HUGE]	only to be used as #{\HUGE ...}#
	    \item[center]	i.e. #\begin{center} ... \end{center}#
	    \item[flushleft]	i.e. #\begin{flushleft} ... \end{flushleft}#
	    \item[flushright]	i.e. #\begin{flushright} ... \end{flushright}#
	    \item[verbatim]	i.e. #\begin{verbatim} ... \end{verbatim}#
	    \item[tabular]	i.e. #\begin{tabular}{lll} ...&...\\ ... \end{tabular}#
	    \item[itemize]	i.e. #\begin{itemize} \item ... ... \end{itemize}#
	    \item[enumerate]	i.e. #\begin{enumerate} \item ... ... \end{enumerate}#
	    \item[description]	i.e. #\begin{description} \item[...] ... ... \end{description}#
	    \end{description}
	    When writing your documentation using only this, you can be sure to get
	    reasonable LaTeX {\bf and} HTML documentation for your code.

	    There are some additional LaTeX macros provided by DOC++:
	    \begin{itemize}
	    \item	\##...#\# corresponds to the LaTeX #\verb!...!#, i.e. outputs
			#...# verbatim.
	    \item	#\Ref{...}# allows to specify a reference to a manual
			entry with name #...#.
	    \item	#\URL{...}# allows to specify a link to the WWW page #...#.
	    \item	#\URL[my text]{...}# allows to specify #my text# as the links
			name.
	    \item	#\TEX{...}# allows to include any complicated LaTeX code
			into you document. For HTML output DOC++ will have LaTeX
			to process it, produce gifs out of it and includes them
			into the HTML document. NOTE: This requires LaTeX,
			dvips, ghostscript and ppmtools to be correctly
			installed to your system!
	    \end{itemize}
	 */

	/** @name supported HTML macros
	    This is the subset of HTML formatting instructions provided by
	    DOC++:
	    \begin{description}
	    \item[#<p>#]		paragraph
	    \item[#<em># ... #<\em>#]	emphasize
	    \item[#<i># ... #<\i>#]	italic
	    \item[#<b># ... #<\b>#]	bold face
	    \item[verbatim]		i.e. #<pre># ... #</pre>#
	    \item[description]		i.e. #<dl># #<dt>#...#<dd># ... #</dl>#
	    \item[itemize]		i.e. #<ul># #<li># ... #</ul>#
	    \item[enumerations]		i.e. #<ll># #<li># ... #</ll>#
	    \end{description}
	 */
    //@}
//@}
